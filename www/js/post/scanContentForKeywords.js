/* eslint no-undef: 0 */

/* scanContentForKeywods er pt. implementeret som en funktion der automatisk kører
 * Når man stopper med at skrive i "content" formen, så vil den automatisk kalde "scanContentForKeywords" algoritmen.
 * Til at opnå dette opstilles de understående eventListeners.
 */

const input = document.getElementById(`content`); // Denne bruges til at scanne det brugeren taster samt hvornår brugeren stopper med at taste
let timeout = null;                               // Denne styrer "pausen" mellem man stopper med at taste, og algoritmen aktivere

input.addEventListener(`keyup`, () => {
  clearTimeout(timeout);            // "Cleare" den forrigt satte timeout, så brugeren ikke får 1 scan pr. tryk på en knap

  timeout = setTimeout(() => {      // Sikrer at funktionen ikke aktivere ved hver enkelt tryk på knappen som brugeren laver
    const keywords = scanContentForKeywords(input);  // aktivere scanContentForKeywords funktionen
    insertKeywords(keywords);
  }, 1000);                         // Bestemmer hvor lang tid brugeren skal vente
});

/* Formål: Scanner content så der bliver fremstillet nøgleord som brugeren kan sortere i.
 *         Funktionen er opbygget så den kan kobles op på flere forskellige algoritmer.
 * Input : @content medsendes fra den forrige eventListener
 * Output: En række kommaseparerede keywords, som outputtes til formen i keyword "value" feltet.
 */
function scanContentForKeywords(content) {
  let wordsInContent = content.value;

  wordsInContent = wordsInContent.replace(/,/g, ``)  // fjerner alle kommaer
    .replace(/\./g, ``) // fjerner alle punktummer
    .replace(/\(/g, ``) // fjerner alle startparenteser
    .replace(/\)/g, ``) // fjerner alle slutparenteser
    .replace(/!/g, ``) // fjerner alle udråbstegn
    .replace(/\?/g, ``) // fjerner alle spørgsmålstegn
    .split(` `);        // omdanner strengen til et array

  let keywords = longWordAlgorithm(wordsInContent);
  keywords = oftenOccurringWordAlgorithm(keywords);

  return keywords;
}

/* ALLE ALGORITMER! */
/* Formål: Alle funktioner herunder er algoritmer der kan "plugges" ind i scanContentForKeywords.
 * Input : @arrayOfWords. alle algoritmer tager et arrayOfWords ind som parameter der scannes på.
 * Output: @keywords. Alle algoritmer outputter en streng af kommaseparerede keywords.
 */

/* Formål: En simpel algoritme der returnere alle ord over en hvis længde, som antages som nøgleord
 * Input : @arrayOfWords funktionen forventer at få et array af ord ind som inputparameter
 * Output: Et opdateret array af ord (keywords i vores tilfælde)
 */
function longWordAlgorithm(arrayOfWords) {
  const DEF_OF_LONG_WORD = 8; // Angiver definition af hvad "et langt ord" betyder
  const keywords = arrayOfWords.filter((word) => word.length > DEF_OF_LONG_WORD); // Frasorterer ord som er mindre end DEF_OF_LONG_WORD
  return keywords;
}

/* Formål: En algoritme der returnere alle de ord, som forekommer flere gange end den gennemsnitlige forekomst af ord i arrayet
 * Input : @arrayOfWords funktionen forventer at få et array af ord ind som inputparameter (keywords i vores tilfælde)
 * Output: Et opdateret array af ord (keywords i vores tilfælde)
 */
function oftenOccurringWordAlgorithm(arrayOfWords) {
  const lowerCaseKeywords = arrayOfWords.map((keyword) => keyword.toLowerCase()); // Sørger for at keyword er det samme som Keyword

  const mapOfKeywords = lowerCaseKeywords.reduce((keywordCountObj, currentKeyword) => { // laver en mapping over hvor mange gange hvert keyword finder sted: { keyword: 5, keyword2: 3 }
    keywordCountObj[currentKeyword] = ++keywordCountObj[currentKeyword] || 1;
    return keywordCountObj;
  }, {});

  const uniqueKeywords = lowerCaseKeywords.filter((value, index) => lowerCaseKeywords.indexOf(value) === index); // Frasorterer duplicates
  const totalKeywordsAmount = lowerCaseKeywords.length;
  const uniqueKeywordsAmount = uniqueKeywords.length;
  const avg = totalKeywordsAmount / uniqueKeywordsAmount;

  const keywords = uniqueKeywords.filter((word) => mapOfKeywords[word] >= avg); // Frasorterer ord som er mindre end gennemsnitslængden

  return keywords;
}


/* Formål: Indsætter fundne keywords fra content i et nyt keyword input felt */
function insertKeywords(keywords) {
  removeInputFields();
  keywords.forEach((longWord, i) => {
    insertKeywordOnPage(longWord, i);
  });
  if (!allKeywordsContainer.firstChild) {
    createInputField(allKeywordsContainer, `Keyword`, 1);
  }
}

/* Formål: HTML håndtering til at indsætte keyword + keyword input felt */
function insertKeywordOnPage(newWord, keyWordNum) {
  const keywordInputFields = allKeywordsContainer.getElementsByTagName(`input`);
  let newKeywordInputField;

  if (keywordInputFields[keyWordNum] && (keywordInputFields[keyWordNum].value === `` || keywordInputFields[keyWordNum].classList.contains(`autoGenerated`))) {
    newKeywordInputField = keywordInputFields[keyWordNum];
  }
  else {
    const newKeywordDiv = createInputField(allKeywordsContainer, `Keyword`, 1); // Kommer fra addAnotherKeyword.js
    newKeywordInputField = newKeywordDiv.getElementsByTagName(`input`)[0]; // eslint-disable-line prefer-destructuring
  }

  newKeywordInputField.parentNode.classList.add(`autoGenerated`);
  newKeywordInputField.disabled = true;
  newKeywordInputField.title = `Dette felt er autogenereret. Derfor kan du ikke ændre dette felt.`;
  newKeywordInputField.value = newWord;
}

/* Formål: fjerner alle autogenerede keyword input fælter  */
function removeInputFields() {
  const autoGeneratedDivs = allKeywordsContainer.getElementsByClassName(`autoGenerated`);

  while (autoGeneratedDivs[0]) {
    allKeywordsContainer.removeChild(autoGeneratedDivs[0]);
  }
}
